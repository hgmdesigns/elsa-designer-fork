import { EventEmitter } from '../../../../stencil-public-runtime';
import { Map } from '../../../../utils/utils';
import { ActivityDescriptor, ActivityDesignDisplayContext, ActivityModel, WorkflowModel } from '../../../../models';
import * as d3 from 'd3';
import dagreD3 from 'dagre-d3';
import { ActivityContextMenuState, LayoutDirection, WorkflowDesignerMode } from "./models";
export declare class ElsaWorkflowDesigner {
  model: WorkflowModel;
  selectedActivityIds: Array<string>;
  activityContextMenuButton?: (activity: ActivityModel) => string;
  activityBorderColor?: (activity: ActivityModel) => string;
  activityContextMenu?: ActivityContextMenuState;
  mode: WorkflowDesignerMode;
  layoutDirection: LayoutDirection;
  workflowChanged: EventEmitter<WorkflowModel>;
  activitySelected: EventEmitter<ActivityModel>;
  activityDeselected: EventEmitter<ActivityModel>;
  activityContextMenuButtonClicked: EventEmitter<ActivityContextMenuState>;
  workflowModel: WorkflowModel;
  activityContextMenuState: ActivityContextMenuState;
  el: HTMLElement;
  svg: SVGElement;
  inner: SVGElement;
  svgD3Selected: d3.Selection<SVGElement, unknown, null, undefined>;
  innerD3Selected: d3.Selection<SVGElement, unknown, null, undefined>;
  zoomParams: {
    x: number;
    y: number;
    scale: number;
  };
  dagreD3Renderer: dagreD3.Render;
  graph: dagreD3.graphlib.Graph;
  zoom: d3.ZoomBehavior<Element, unknown>;
  parentActivityId?: string;
  parentActivityOutcome?: string;
  addingActivity: boolean;
  activityDisplayContexts: Map<ActivityDesignDisplayContext>;
  selectedActivities: Map<ActivityModel>;
  handleContextMenuChange(state: ActivityContextMenuState): void;
  handleModelChanged(newValue: WorkflowModel): void;
  handleSelectedActivityIdsChanged(newValue: Array<string>): void;
  handleActivityContextMenuChanged(newValue: ActivityContextMenuState): void;
  removeActivity(activity: ActivityModel): Promise<void>;
  showActivityEditor(activity: ActivityModel, animate: boolean): Promise<void>;
  connectedCallback(): void;
  disconnectedCallback(): void;
  componentWillLoad(): void;
  componentDidLoad(): void;
  componentWillRender(): void;
  showActivityEditorInternal(activity: ActivityModel, animate: boolean): void;
  handleEditActivity(activity: ActivityModel): void;
  updateWorkflowModel(model: WorkflowModel, emitEvent?: boolean): void;
  cleanWorkflowModel(model: WorkflowModel): WorkflowModel;
  removeActivityInternal(activity: ActivityModel): void;
  onActivityPicked: (args: any) => Promise<void>;
  onUpdateActivity: (args: any) => void;
  newActivity(activityDescriptor: ActivityDescriptor): ActivityModel;
  createAndAddActivity(activityDescriptor: ActivityDescriptor, sourceActivityId?: string, targetActivityId?: string, outcome?: string): ActivityModel;
  addActivity(activity: ActivityModel, sourceActivityId?: string, targetActivityId?: string, outcome?: string): void;
  getRootActivities(): Array<ActivityModel>;
  addConnection(sourceActivityId: string, targetActivityId: string, outcome: string): void;
  updateActivity(activity: ActivityModel): void;
  showActivityPicker(): void;
  removeConnection(sourceId: string, outcome: string): void;
  applyZoom(): void;
  setEntities(): void;
  tryRerenderTree(waitTime?: number, attempt?: number): void;
  renderNodes(): void;
  rerenderTree(): void;
  createActivityOptions(activity: ActivityModel): {
    shape: string;
    label: string;
    rx: number;
    ry: number;
    labelType: string;
    class: string;
    activity: ActivityModel;
  };
  createOutcomeActivityOptions(): {
    shape: string;
    label: string;
    labelType: string;
    class: string;
    width: number;
    height: number;
  };
  renderOutcomeButton(): string;
  renderActivity(activity: ActivityModel): string;
  renderActivityBody(displayContext: ActivityDesignDisplayContext): string;
  renderActivityProperties(property: any): string;
  render(): any;
}
